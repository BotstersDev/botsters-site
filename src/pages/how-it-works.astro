---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout
  title="How It Works"
  description="How the Brain/Spine/Actuator architecture gives AI agents real capability without credential exposure ‚Äî and why that matters."
>
  <section class="hero">
    <div class="container">
      <div class="hero-content">
        <p class="hero-eyebrow">Architecture Deep Dive</p>
        <h1>How Botsters Works</h1>
        <p>
          Four hard questions about AI agent security ‚Äî answered directly.
        </p>
      </div>
    </div>
  </section>

  <nav class="toc-bar">
    <div class="container">
      <ul class="toc-links">
        <li><a href="#blind-auth">Blind Auth</a></li>
        <li><a href="#guaranteed-logging">Guaranteed Logging</a></li>
        <li><a href="#bsa-vs-openclaw">BSA vs. OpenClaw</a></li>
        <li><a href="#why-not-firewall">Why Not a Firewall?</a></li>
      </ul>
    </div>
  </nav>

  <!-- Q1 -->
  <section class="section" id="blind-auth">
    <div class="container">
      <div class="article">
        <div class="q-label">Question 1</div>
        <h2>How can agents get work done without being able to see any auth?</h2>

        <p>
          Two complementary mechanisms: <strong>seksh</strong> (the secure shell) and
          <strong>agent-tools</strong> (capability-based CLI wrappers). Both ensure that
          real credentials are injected at the last possible moment ‚Äî inside the tool, not
          in the agent's environment.
        </p>

        <h3>seksh ‚Äî AST-level secret injection</h3>
        <p>
          seksh is a fork of Nushell with broker-aware secret management built into the
          language runtime. Secrets are injected directly into the Abstract Syntax Tree
          at parse time ‚Äî they never exist as string values in the shell environment.
        </p>
        <p>
          This works like prepared statements in SQL. When a database driver processes
          <code>SELECT * FROM users WHERE id = ?</code>, the user input is bound inside the
          driver ‚Äî it never gets concatenated into raw SQL where it could be read or escaped.
          seksh works the same way: the secret is bound inside the AST, not interpolated
          into a string the shell can read.
        </p>
        <p>
          The consequence is that even explicit extraction attempts fail safely:
        </p>

        <div class="code-demo">
          <div class="code-demo-label">What an agent sees if it tries to extract a secret</div>
          <pre><code># Attempting to echo a secret ‚Äî seksh returns a placeholder, not the value
> echo (getseks MY_OAUTH_TOKEN)
&lt;secret:MY_OAUTH_TOKEN&gt;

# The secret is usable, but not readable
> seksh-http get https://api.github.com/user --auth-bearer MY_OAUTH_TOKEN
# ‚Üí authenticated request succeeds, token never appears in output</code></pre>
        </div>

        <p>
          An agent operating under prompt injection, or one explicitly instructed to exfiltrate
          credentials, encounters a dead end. The value isn't there to steal.
        </p>

        <h3>agent-tools ‚Äî capability-scoped wrappers</h3>
        <p>
          agent-tools is a suite of CLI tools that wrap common authenticated operations.
          Agents invoke them by capability name ‚Äî the Spine resolves the actual credentials
          and enforces what the call is allowed to do.
        </p>

        <div class="grid grid-3" style="margin: 2rem 0;">
          <div class="card">
            <h3>üåê agent-http</h3>
            <p>HTTP client with broker-injected auth. Supports bearer tokens, basic auth, and capability-based resolution.</p>
            <pre><code>agent-http get \
  https://api.github.com/user \
  --auth-bearer github/pat</code></pre>
          </div>
          <div class="card">
            <h3>üîÄ agent-git</h3>
            <p>git wrapper that injects credentials into HTTPS URLs at execution time. No tokens in shell history.</p>
            <pre><code>agent-git clone \
  https://github.com/org/repo \
  --auth-token github/pat</code></pre>
          </div>
          <div class="card">
            <h3>üéØ do-agent</h3>
            <p>Capability-first interface. Agents request provider actions by name; the Spine handles auth and routing.</p>
            <pre><code>do-agent github \
  list-repos \
  --org myorg</code></pre>
          </div>
        </div>

        <div class="card" style="margin-bottom: 2rem;">
          <h3>üìã listagent</h3>
          <p>Lists available secrets and capabilities by name ‚Äî never by value. Agents can discover what they have access to without ever seeing the underlying credentials.</p>
          <pre><code>listagent --capabilities
# ‚Üí github/read, github/write, cloudflare/deploy, hetzner/dns ...</code></pre>
        </div>

        <h3>Capability scoping ‚Äî knowing what goes in and out</h3>
        <p>
          Because agent-tools wrap known API surfaces, the Spine understands the schema of
          every call. It knows what parameters are valid inputs and what a legitimate response
          looks like. This enables two things standard shell access cannot provide:
        </p>
        <ul>
          <li>
            <strong>Inbound scoping:</strong> Credentials are only injected into calls that
            match the registered capability. An agent with <code>github/read</code> cannot
            use that grant to authenticate a write operation ‚Äî the Spine rejects the mismatch
            before the call goes out.
          </li>
          <li>
            <strong>Outbound scrubbing:</strong> Because the Spine knows what a valid API
            response looks like, it can detect and redact any credential values that appear
            in return data ‚Äî catching cases where an API accidentally echoes auth material
            back in an error message or header.
          </li>
        </ul>

        <div class="notice notice-success">
          <strong>The guarantee:</strong> A compromised agent can't exfiltrate what it never
          had. seksh's AST injection and agent-tools' capability scoping together ensure
          credentials exist only inside the tool at execution time ‚Äî never as readable
          values in the agent's environment, shell history, or logs.
        </div>
      </div>
    </div>
  </section>

  <!-- Q2 -->
  <section class="section section-dark" id="guaranteed-logging">
    <div class="container">
      <div class="article">
        <div class="q-label">Question 2</div>
        <h2>Why does the Spine guarantee logging and attestation?</h2>
        <p class="subtitle-note">Both inference and actuator actions.</p>

        <p>
          In a standard agent setup, logging is optional ‚Äî an afterthought bolted on by whoever
          built the integration. The agent might log. Or it might not. When something goes wrong,
          you're reconstructing what happened from fragments.
        </p>
        <p>
          The Spine makes logging <em>structurally mandatory</em>, not a configuration choice.
        </p>

        <h3>Why "guaranteed" isn't just a claim</h3>
        <p>
          Every outbound call ‚Äî inference requests to Claude/GPT/Gemini, tool calls, shell
          commands, file operations, API calls to external services ‚Äî flows through the Spine.
          There is no bypass. An agent that wants to do anything has to go through the Spine,
          and the Spine logs everything before dispatching.
        </p>

        <div class="grid grid-2" style="margin: 2rem 0;">
          <div class="card">
            <h3>üìù Inference Logging</h3>
            <p>
              Every model call is logged: timestamp, agent identity, model used, token counts,
              and response hash. The Spine proxies all inference traffic ‚Äî there is no path
              for an agent to call a model without leaving a record.
            </p>
            <p>
              This also enables cost attribution across a multi-agent system ‚Äî you know exactly
              which agent spent how much.
            </p>
          </div>
          <div class="card">
            <h3>‚öôÔ∏è Actuator Action Logging</h3>
            <p>
              Every task dispatched to an Actuator ‚Äî shell command, file write, git operation,
              browser action ‚Äî is logged before execution, with the requesting agent's identity
              attached.
            </p>
            <p>
              The Actuator cannot receive a task without the Spine having recorded it first.
              Execution and logging are not separable steps.
            </p>
          </div>
        </div>

        <h3>Attestation of where the agent is running</h3>
        <p>
          The Spine doesn't just log <em>what</em> an agent does ‚Äî it attests to <em>where</em>
          it's running. Each Brain connects to the Spine through a registered identity, and
          the Spine verifies that identity on every session. An agent cannot silently migrate
          to a different host, clone itself to a new environment, or operate outside its
          registered Actuator ‚Äî because without the Spine connection, it literally cannot think.
        </p>
        <p>
          Unlike a standard OpenClaw setup, a Botsters Brain cannot abscond with its OAuth
          token or API key for inference. The inference credentials live in the Spine. A Brain
          that loses its Spine connection loses the ability to call any model at all. There is
          no "offline mode" that preserves access ‚Äî the connection to the Spine is the access.
        </p>

        <div class="notice notice-info">
          <strong>Why this matters for compliance and incident response:</strong> When an agent
          does something unexpected, you have a complete, tamper-resistant record ‚Äî not just
          of what it told the model, but of every external action it took, and verified knowledge
          of which registered environment it was running in when it did so.
        </div>

        <h3>Attestation: knowing logs haven't been tampered with</h3>
        <p>
          Logging is only useful if you can trust the logs. The Spine provides attestation by
          being the sole authorized intermediary ‚Äî neither Brains nor Actuators write directly
          to the log store. An agent cannot delete or alter its own log entries because it has
          no interface to do so. Log integrity is enforced by access architecture, not by
          trusting the agents themselves.
        </p>

        <h3>The comparison</h3>
        <div class="comparison-table">
          <div class="comparison-row comparison-header">
            <div>Concern</div>
            <div>Standard OpenClaw</div>
            <div>BSA (Spine)</div>
          </div>
          <div class="comparison-row">
            <div>Inference logging</div>
            <div class="neg">Optional / provider-side only</div>
            <div class="pos">Mandatory, agent-attributed</div>
          </div>
          <div class="comparison-row">
            <div>Tool call logging</div>
            <div class="neg">If the agent logs it</div>
            <div class="pos">Mandatory, pre-execution</div>
          </div>
          <div class="comparison-row">
            <div>Shell command logging</div>
            <div class="neg">Shell history, if not cleared</div>
            <div class="pos">Mandatory via Actuator dispatch</div>
          </div>
          <div class="comparison-row">
            <div>Log integrity</div>
            <div class="neg">Agent has write access</div>
            <div class="pos">Agent has no log interface</div>
          </div>
          <div class="comparison-row">
            <div>Execution environment attestation</div>
            <div class="neg">Not available</div>
            <div class="pos">Verified per session</div>
          </div>
          <div class="comparison-row">
            <div>Inference credentials</div>
            <div class="neg">In agent environment</div>
            <div class="pos">Spine-only; Brain can't operate without connection</div>
          </div>
          <div class="comparison-row">
            <div>Cost attribution</div>
            <div class="neg">Per-account only</div>
            <div class="pos">Per-agent, per-task</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Q3 -->
  <section class="section" id="bsa-vs-openclaw">
    <div class="container">
      <div class="article">
        <div class="q-label">Question 3</div>
        <h2>Why is Brain/Spine/Actuator superior to standard OpenClaw?</h2>

        <p>
          OpenClaw is excellent software ‚Äî the Botsters Brain is built on an OpenClaw fork.
          This isn't a criticism of OpenClaw. It's an observation that OpenClaw is designed
          for a different threat model: a trusted operator running an agent on trusted
          infrastructure with well-understood tool access.
        </p>
        <p>
          That assumption breaks down when agents operate autonomously for extended periods,
          process untrusted input, share infrastructure with other agents, or run in contexts
          where you need to audit behavior after the fact.
        </p>

        <h3>The architectural difference</h3>

        <div class="arch-compare">
          <div class="arch-box arch-standard">
            <h4>Standard OpenClaw</h4>
            <div class="arch-diagram">
              <div class="arch-node">üß† Brain + Tools</div>
              <div class="arch-arrow-down">‚Üì</div>
              <div class="arch-node arch-secrets-node">üîë Secrets (in env)</div>
              <div class="arch-arrow-down">‚Üì</div>
              <div class="arch-node">Shell / APIs / Files</div>
            </div>
            <ul class="arch-notes">
              <li>Single trust boundary</li>
              <li>Credentials in agent environment</li>
              <li>Agent can log ‚Äî or not</li>
              <li>All capabilities always available</li>
              <li>Compromise = full access to secrets and tools</li>
            </ul>
          </div>

          <div class="arch-box arch-bsa">
            <h4>Brain / Spine / Actuator</h4>
            <div class="arch-diagram">
              <div class="arch-node">üß† Brain</div>
              <div class="arch-arrow-down">‚Üì</div>
              <div class="arch-node arch-spine-node">ü¶¥ Spine</div>
              <div class="arch-nodes-row">
                <div class="arch-node arch-small">üîë Secrets Vault</div>
                <div class="arch-node arch-small">üìã Audit Log</div>
              </div>
              <div class="arch-arrow-down">‚Üì</div>
              <div class="arch-node">‚öôÔ∏è Actuator</div>
              <div class="arch-arrow-down">‚Üì</div>
              <div class="arch-node">Shell / APIs / Files</div>
            </div>
            <ul class="arch-notes">
              <li>Three distinct trust boundaries</li>
              <li>Credentials isolated in Spine vault</li>
              <li>Logging mandatory by structure</li>
              <li>Capabilities scoped per actuator</li>
              <li>Compromise of Brain yields no secrets</li>
            </ul>
          </div>
        </div>

        <h3>Separation of concerns ‚Äî for real</h3>
        <p>
          In the BSA model, the Brain <em>decides</em> but doesn't <em>execute</em>. The
          Actuator <em>executes</em> but doesn't <em>reason</em>. The Spine <em>mediates</em>
          ‚Äî handling credentials, routing, logging, and policy enforcement. Each layer does
          one thing and is auditable in isolation.
        </p>
        <p>
          This also means each layer can evolve independently. You can swap the Brain for a
          different model provider, update the Actuator runtime, or harden the Spine's
          credential handling ‚Äî without touching the other layers.
        </p>

        <h3>Capability scoping</h3>
        <p>
          Each Actuator registers the capabilities it supports: <code>shell</code>,
          <code>git</code>, <code>browser</code>, <code>file-system</code>, and so on.
          The Brain requests tasks by capability. The Spine routes to a matched Actuator
          and enforces that the task matches the registered capability profile.
        </p>
        <p>
          A Brain that should only do code review cannot run shell commands if no
          <code>shell</code>-capable Actuator is registered for it. The constraint is
          structural ‚Äî you're not relying on the agent to remember what it's not supposed to do.
        </p>
        <p>
          Capability scoping also applies to API calls made through agent-tools. Because the
          Spine knows the schema of each registered capability, it knows what parameters are
          valid inputs and what a legitimate response looks like. Credentials are only injected
          into calls that match the capability's definition ‚Äî and responses are scrubbed against
          the same schema before being returned to the agent.
        </p>
      </div>
    </div>
  </section>

  <!-- Q4 -->
  <section class="section section-dark" id="why-not-firewall">
    <div class="container">
      <div class="article">
        <div class="q-label">Question 4</div>
        <h2>Why not just firewall or sandbox OpenClaw?</h2>

        <p>
          Standard OpenClaw has a fundamental structural problem that a firewall cannot fix:
          <strong>the attack surface and the secrets share the same boundary.</strong>
          The agent processes untrusted input and holds credentials in the same environment.
          A firewall controls where traffic goes ‚Äî it does nothing about what's already inside.
        </p>

        <p>
          BSA eliminates this by separating the attack surface from the secrets entirely.
          The Brain ‚Äî which processes untrusted content, executes tools, and is the most
          exposed layer ‚Äî never holds credentials. The secrets live in the Spine, which
          the Brain cannot directly access. A successful attack on the Brain yields nothing
          it can use to escalate.
        </p>

        <h3>The other problem: who controls the firewall?</h3>

        <p>
          A firewall or sandboxing product for OpenClaw agents poses a dilemma that has
          no good answer within that architecture:
        </p>

        <div class="grid grid-2" style="margin: 2rem 0;">
          <div class="card card-problem">
            <h3>üè¢ On-premise firewall product</h3>
            <p>
              You're running third-party security software in your own data center. That software
              has visibility into your agents' inference traffic, tool calls, and potentially
              the credentials your agents hold. You're trusting a vendor's product with your
              most sensitive agent activity ‚Äî and it's running inside your perimeter.
            </p>
          </div>
          <div class="card card-problem">
            <h3>‚òÅÔ∏è Cloud-based proxy / CASB</h3>
            <p>
              All of your AI agent inference data ‚Äî every prompt, every tool call, every
              response ‚Äî leaves your network and transits through a third party's infrastructure.
              You've traded one security problem (unsandboxed agents) for another (sensitive
              inference data leaving the company firewall).
            </p>
          </div>
        </div>

        <p>
          With Botsters, <strong>the customer controls the Spine.</strong> The Spine is
          deployable in your own infrastructure ‚Äî your data center, your VPC, your rules.
          It holds all secrets, all logging, all attestation. Nothing about your agents'
          behavior has to transit a third-party network. The security product isn't a vendor
          black box sitting in your environment ‚Äî it's your own infrastructure, built on
          open software.
        </p>

        <h3>What a firewall specifically cannot do</h3>
        <div class="grid grid-2" style="margin: 2rem 0;">
          <div class="card">
            <h3>‚ùå Identity</h3>
            <p>
              A firewall sees traffic to <code>api.github.com</code>. It doesn't know
              whether that request came from your coding agent following instructions,
              or a compromised agent exfiltrating repository contents via prompt injection.
            </p>
          </div>
          <div class="card">
            <h3>‚ùå Credential Containment</h3>
            <p>
              A firewall doesn't prevent an agent from reading credentials that are already
              in its environment and encoding them in a permitted outbound request ‚Äî to a
              whitelisted domain, in a query parameter, in a JSON body. Exfiltration within
              allowed destinations is invisible to a network filter.
            </p>
          </div>
          <div class="card">
            <h3>‚ùå Semantic Logging</h3>
            <p>
              Firewall logs record connections: source, destination, bytes. They don't
              record that the agent deleted a file, committed to main, or made a 50,000-token
              inference call. Agent behavior cannot be reconstructed from network logs alone.
            </p>
          </div>
          <div class="card">
            <h3>‚ùå Fine-Grained Revocation</h3>
            <p>
              To stop a compromised agent at the network level, you block its IP ‚Äî which
              blocks everything on that host. The Spine revokes a single agent token in
              milliseconds, without affecting any other agent or service.
            </p>
          </div>
        </div>

        <h3>Defense in depth</h3>
        <p>
          Firewalls and the Spine aren't alternatives ‚Äî they're complementary. A firewall
          is a good perimeter control that prevents agents from reaching destinations they
          should never reach. The Spine covers what a firewall cannot:
        </p>
        <ul>
          <li><strong>Network layer:</strong> Firewall + egress allowlist ‚Äî stops obvious bad destinations</li>
          <li><strong>Application layer:</strong> Spine ‚Äî identity, credentials, logging, revocation, owned by you</li>
          <li><strong>Execution layer:</strong> Actuator capability scoping ‚Äî limits what agents can do structurally</li>
          <li><strong>Content layer:</strong> Output scrubbing ‚Äî catches credentials in responses</li>
        </ul>
        <p>
          A firewall alone covers one of these four layers. BSA covers the other three ‚Äî
          and does so on infrastructure you control, with no third-party visibility into
          your agents' inference traffic.
        </p>
      </div>
    </div>
  </section>

  <section class="section">
    <div class="container cta-section">
      <h2>Ready to go deeper?</h2>
      <p>
        The architecture is open. Read the docs, explore the code, or get in touch.
      </p>
      <div class="cta-buttons">
        <a href="https://github.com/BotstersDev" class="btn btn-primary" target="_blank">View on GitHub</a>
        <a href="/software" class="btn btn-secondary">Software</a>
        <a href="/feedback" class="btn btn-ghost">Ask a Question</a>
      </div>
    </div>
  </section>
</BaseLayout>

<style>
  .hero {
    padding: 6rem 0 4rem;
    text-align: center;
    background: linear-gradient(135deg, rgba(255, 107, 53, 0.08) 0%, rgba(220, 38, 38, 0.04) 100%);
  }

  .hero-eyebrow {
    font-size: 0.85rem;
    font-weight: 700;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--color-accent);
    margin-bottom: 1rem;
  }

  .hero h1 {
    font-size: 3.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, var(--color-accent), var(--color-amber));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.1;
    margin-bottom: 1.25rem;
  }

  .hero p {
    font-size: 1.2rem;
    color: var(--color-text-muted);
    max-width: 600px;
    margin: 0 auto;
  }

  .toc-bar {
    background: var(--color-bg-secondary);
    border-bottom: 1px solid var(--border-muted);
    position: sticky;
    top: 57px;
    z-index: 90;
  }

  .toc-links {
    display: flex;
    gap: 0;
    list-style: none;
    padding: 0;
    overflow-x: auto;
  }

  .toc-links a {
    display: block;
    padding: 1rem 1.5rem;
    color: var(--color-text-muted);
    font-size: 0.9rem;
    font-weight: 500;
    white-space: nowrap;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
  }

  .toc-links a:hover {
    color: var(--color-accent);
    border-bottom-color: var(--color-accent);
    background: rgba(255, 107, 53, 0.05);
  }

  .article h2 {
    font-size: 2rem;
    font-weight: 800;
    color: var(--color-accent);
    margin: 0 0 1.5rem;
    line-height: 1.2;
  }

  .article h3 {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--color-amber);
    margin: 2.5rem 0 1rem;
  }

  .article p {
    margin-bottom: 1.25rem;
    color: var(--color-text);
    line-height: 1.7;
  }

  .article ul {
    margin: 1rem 0 1.5rem 1.5rem;
  }

  .article ul li {
    margin-bottom: 0.6rem;
    color: var(--color-text);
    line-height: 1.6;
  }

  .q-label {
    display: inline-block;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--color-text-dim);
    background: var(--color-bg-tertiary);
    border: 1px solid var(--border-muted);
    border-radius: 4px;
    padding: 0.25rem 0.75rem;
    margin-bottom: 1rem;
  }

  .subtitle-note {
    color: var(--color-text-muted) !important;
    font-style: italic;
    margin-top: -1rem !important;
    margin-bottom: 2rem !important;
  }

  /* Code demo block */
  .code-demo {
    margin: 2rem 0;
    border: 1px solid var(--border-muted);
    border-radius: 8px;
    overflow: hidden;
  }

  .code-demo-label {
    background: var(--color-bg-tertiary);
    padding: 0.6rem 1.25rem;
    font-size: 0.8rem;
    color: var(--color-text-muted);
    font-weight: 600;
    border-bottom: 1px solid var(--border-muted);
  }

  .code-demo pre {
    margin: 0;
    border: none;
    border-radius: 0;
    padding: 1.25rem;
    font-size: 0.875rem;
  }

  /* grid-3 override for agent-tools cards */
  .grid-3 .card pre {
    font-size: 0.78rem;
    padding: 0.75rem;
    margin-top: 0.75rem;
  }

  /* Comparison table */
  .comparison-table {
    border: 1px solid var(--border-muted);
    border-radius: 8px;
    overflow: hidden;
    margin: 2rem 0;
  }

  .comparison-row {
    display: grid;
    grid-template-columns: 2fr 2fr 2fr;
    border-bottom: 1px solid var(--border-muted);
  }

  .comparison-row:last-child { border-bottom: none; }

  .comparison-row > div {
    padding: 0.9rem 1.25rem;
    font-size: 0.875rem;
    line-height: 1.4;
  }

  .comparison-header {
    background: var(--color-bg-tertiary);
    font-weight: 700;
    font-size: 0.78rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
  }

  .comparison-row:nth-child(even):not(.comparison-header) {
    background: rgba(255,255,255,0.02);
  }

  .pos { color: var(--color-success); font-weight: 500; }
  .neg { color: var(--color-text-muted); }

  /* Arch compare */
  .arch-compare {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin: 2rem 0;
  }

  .arch-box {
    padding: 2rem;
    border-radius: 12px;
    border: 1px solid var(--border-muted);
  }

  .arch-standard { background: var(--color-bg-secondary); }

  .arch-bsa {
    background: rgba(255, 107, 53, 0.05);
    border-color: rgba(255, 107, 53, 0.3);
  }

  .arch-box h4 {
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--color-text-muted);
    margin-bottom: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  .arch-bsa h4 { color: var(--color-accent); }

  .arch-diagram {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.3rem;
    margin-bottom: 1.5rem;
    padding: 1.25rem;
    background: rgba(0,0,0,0.25);
    border-radius: 8px;
    font-family: var(--font-mono);
    font-size: 0.82rem;
  }

  .arch-node {
    padding: 0.4rem 1rem;
    background: var(--color-bg-tertiary);
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    white-space: nowrap;
  }

  .arch-spine-node {
    border-color: var(--color-accent);
    color: var(--color-accent);
  }

  .arch-secrets-node {
    border-color: var(--color-red);
    color: var(--color-danger);
  }

  .arch-nodes-row {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .arch-small {
    font-size: 0.75rem;
    padding: 0.3rem 0.75rem;
  }

  .arch-arrow-down {
    color: var(--color-text-dim);
    font-size: 0.78rem;
  }

  .arch-notes {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .arch-notes li {
    padding: 0.4rem 0;
    font-size: 0.875rem;
    color: var(--color-text-muted);
    border-bottom: 1px solid var(--border-muted);
  }

  .arch-notes li:last-child { border-bottom: none; }
  .arch-bsa .arch-notes li { color: var(--color-text); }

  /* Problem cards for Q4 */
  .card-problem {
    border-color: rgba(220, 38, 38, 0.3);
    background: rgba(220, 38, 38, 0.05);
  }

  .card-problem h3 { color: var(--color-danger); }

  /* CTA */
  .cta-section { text-align: center; }
  .cta-section h2 { font-size: 2rem; margin-bottom: 1rem; }
  .cta-section p {
    color: var(--color-text-muted);
    margin-bottom: 2rem;
    max-width: 500px;
    margin-left: auto;
    margin-right: auto;
  }
  .cta-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  @media (max-width: 768px) {
    .hero h1 { font-size: 2.25rem; }
    .comparison-row { grid-template-columns: 1fr; }
    .comparison-header { display: none; }
    .comparison-row > div:first-child {
      font-weight: 700;
      color: var(--color-amber);
      padding-bottom: 0;
    }
    .arch-compare { grid-template-columns: 1fr; }
  }
</style>
